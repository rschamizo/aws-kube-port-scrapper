= Ansible

Ansible execution is based on 2 roles, and a main playbook that orchestrates the entire flow. All the execution is configured in the different yamls of the folder vars/, helm_templates/ and files/

All the variables begin with 3 letters that allow us to identify their origin, the different variables that we will see in this execution are:

* anm__ -> High-level variables to parameterize which roles or features to enable/disable. In this execution it is not very relevant, but in more complex projects it is very useful.
* cms__ -> Variables present in all roles
* glb__ -> Variables shared between different roles
* trf__ -> terraform role variables
* pts__ -> port_scrapper role variables
* dyn__ -> Variables autogenerated internally by one of the roles

There is another role, which should not be used as it is not finalized yet, which would allow you to prepare the machine running the playbook with all the necessary dependencies regardless of the operating system. As it is not debugged, it is necessary to install some dependencies manually.

== Prerequisites
A Linux computer is required, either a workstation or a hardened machine that has access to the Kubernetes API in question.
Attached to the ansible folder is a role whose idea was to prepare the operating system with the necessary packages, but it is not yet operational. Failing that, the steps to install the necessary packages on an Ubuntu 20.04 system are detailed.

=== kubectl
[source,bash]
----
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
----

It is necessary that the active user in the session where ansible is executed already has the necessary permissions against the cluster in question.

=== Buildah
It is only necessary if you want to modify any of the scripts, as it will be used to build the image.

[source,bash]
----
. /etc/os-release
sudo sh -c "echo 'deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/xUbuntu_${VERSION_ID}/ /' > /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list"
wget -nv https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable/xUbuntu_${VERSION_ID}/Release.key -O Release.key
sudo apt-key add - < Release.key
sudo apt-get update -qq
sudo apt-get -qq -y install buildah
----

=== keybase (as non root)
Necesario para la autogeneracion de recursos en aws. 

[source,bash]
----
curl --remote-name https://prerelease.keybase.io/keybase_amd64.deb
sudo apt install ./keybase_amd64.deb
run_keybase
----
You also need to register at https://keybase.io/docs/the_app/install_linux. This will allow encrypting the AWS user keys that will be generated, with pgp keys. The session that executes ansible must be able to execute the keybase command logged in with the user configured in the terraform variables.

=== Terraform

[source,bash]
----
sudo apt-get update && sudo apt-get install -y gnupg software-properties-common curl
curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo apt-key add -
sudo apt-add-repository "deb [arch=amd64] https://apt.releases.hashicorp.com $(lsb_release -cs) main"
sudo apt-get update && sudo apt-get install terraform
----

=== Helm

[source,bash]
----
curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
chmod 700 get_helm.sh
./get_helm.sh
----

Let's analyze the variables of the globals.yaml. In this file we find many interesting variables, here we can change the name of the resources that are going to be created from dynamodb, s3 or sns. The full flow of ansible assumes that these resources are created by the terraform module. Here it is important to note the email that will be notified, and the name of the cluster that we are going to use. It is important because the terraform module must give permissions on that resource to the created IAM user.

The next file to check is the terraform_scrapper.yaml. Here we have many variables that refer to the global variables defined before so we don't have to touch them. The only important one here would be the keybase user that is going to be used to encrypt the IAM users. You must exit prior to executing terraform.


== Port-scrapper

The next file is the port_scrapper.yaml. This contains quite a bit of information. On the one hand we have the associations with the variables generated by the terraform module. On the other hand, we have the docker image generation module, which is disabled by default and refers to a previously built image. Modifying the scripts and enabling the variable in the ansible_managment.yaml will activate the functionality of creating the images and pushing them to the repository. This forces to set a secret variable with the user's password, so that the buildah can login.

For this it is necessary to set up a 'vault identity'. It is done in the ansible.cfg file, referring to a file that contains only a password that will encrypt all the necessary files.

Ejemplo:

[source,bash]
----
[defaults]
inventory=inventory
vault_identity_list = rschamizo@vaults_passwords/.rschamizo
----
And inside vaults_passwords/.rschamizo there should be only one string that will serve as password

The following commands will only work from the directory where the ansible.cfg is after performing the steps above.

[source,bash]
----
ansible-vault create --encrypt-vault-id varas/vault_persona.yaml
ansible-vault edit --encrypt-vault-id rschamizo vars/vault_rschamizo.ym
----

The variables in the 'Scrapper Execution Settings' section parameterize the cronjob to be created. We can modify the frequency, the ports that are going to be excluded and the namespaces that are going to be created. Reference is made to the aws configuration file where it is necessary to enter the new IAM user that we have created. It will be added to the configuration dynamically.

Finally, there are the variables that configure the part of the alerts. Here we can choose the version of the helm chart of prometheus. Do not modify the rest of the values.

In the helm_templates is the values ​​with which prometheus will be displayed. In this case it does not have any variables, but in general it is templated using jinja2 so that the ansible itself can modify some of the parameters according to the necessary logic. Custom alerts are included here, and you can manually modify any necessary parameters. It is important to note that jinja2 uses {{ }} to perform the template, so if there are comments with such values, they must be enclosed in {% raw %} {% endraw %} clauses as seen on line 1343.

In files/ we have some files that we can also modify, such as the permissions that the IAM user will have in the kube-role-and-binding. Or the alertmanager-conf.j2 configuration. Important not to touch the values ​​that are taken from the ansible configuration.

Once all the files are configured the way you want, and all the requirements are met, just run the playbook inside the ansible/ directory.

[source,bash]
----
ansible-playbook main.yaml 
----